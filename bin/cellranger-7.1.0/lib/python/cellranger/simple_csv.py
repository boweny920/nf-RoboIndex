#
# Copyright (c) 2020 10X Genomics, Inc. All rights reserved
#
"""Interface for reading and writing "simple" CSVs.

A CSV is defined to be simple if the dtype of each
column can be inferred by reading the first row. For example, this requires any string column to be
fixed width where the corresponding entry in the first row could be used to compute that width. In
addition, a column of integers cannot have a missing value -> such columns should be float and any
missing values must be "NaN". A number of CSVs generated by stages follow this pattern. Use the
SimpleCSV class to represent such objects.
"""

from __future__ import annotations

from collections.abc import Iterable
from typing import Optional

import numpy as np
import pandas as pd
from six import ensure_binary, ensure_str


def read_simple_csv(file_path: str, *, float_precision: str = "high", **kwargs):
    """Wrapper around pandas.read_csv that converts _all_ string type columns to bytes.

    Args:
        file_path (AnyStr): Path to CSV
        float_precision: See pandas documentation.
        **kwargs: Additional arguments passed to `pd.read_csv`.

    Returns:
        pd.DataFrame: DataFrame object with all string columns cast to bytes
    """
    df = pd.read_csv(file_path, float_precision=float_precision, **kwargs)

    if df.shape and df.shape[0]:
        for col in df.columns:
            value = df[col].iloc[0]
            if isinstance(value, str):
                df[col] = df[col].astype("S")
    return df


class SimpleCSV:
    """A collection of numpy arrays consisting of int/float/fixed-length strings."""

    COLUMNS_FIELD = "__columns__"

    def __init__(self, columns: Optional[list[str]] = None):
        """Initialize object.

        Args:
            columns (list, optional): Specify column names at initialization. Defaults to None.
        """
        self.columns: list[str] = []
        self.shape = tuple()
        if columns:
            # no duplicate column headers
            assert len(columns) == len(set(columns))
            for col in columns:
                assert col != SimpleCSV.COLUMNS_FIELD
            self.columns = columns
            self.shape = (0, len(columns))
        self.dtypes = {}

    def __setitem__(self, key: str, value: np.ndarray):
        assert isinstance(value, np.ndarray)
        assert len(value.shape) == 1
        assert key != SimpleCSV.COLUMNS_FIELD, "the field {} is reserved".format(
            SimpleCSV.COLUMNS_FIELD
        )
        # if dataframe is non-empty any new column must agree with current shape
        if self.shape and self.shape[0]:
            assert value.shape[0] == self.shape[0]
        self.shape = (value.shape[0], len(self.columns))
        if key not in self.columns:
            self.columns.append(key)
            self.shape = (value.shape[0], len(self.columns))
        self.dtypes[key] = value.dtype
        self.__setattr__(key, value)

    def __getitem__(self, key: str):
        return self.__getattribute__(key)

    def __str__(self):
        pieces = []
        for col in self.columns:
            pieces.append(f"{col}: {self.__getattribute__(col)}")
        return "\n".join(pieces)

    def subset_columns(self, columns: Iterable[str]):
        """Select a subset of columns.

        Args:
            columns (list): list of columns to be selected

        Returns:
            SimpleCSV: subset data frame
        """
        subset = SimpleCSV()
        for col in columns:
            assert col in self.columns
            subset[col] = self[col]
        return subset

    def subset_rows_mask(self, mask):
        """Select a subset of rows using a mask.

        Args:
            mask (numpy.ndarray): boolean vector indicating rows that are to be chosen

        Returns:
            SimpleCSV: subset data frame
        """

        assert isinstance(mask, np.ndarray)
        assert len(mask.shape) == 1
        assert mask.shape[0] == self.shape[0]
        assert mask.dtype == bool
        subset = SimpleCSV()
        for col in self.columns:
            subset[col] = self[col][mask]
        return subset

    def row_sum(self):
        """Compute the sum over all rows (axis=0) for each column.

        Returns:
            dict: row sum in the form {col: row sum}
        """
        result = {}
        for col in self.columns:
            result[col] = self[col].sum()
        return result

    def to_npz(self, file_path_or_handle):
        """Save CSV to a .npz file readable by numpy.

        Args:
            file_path_or_handle (bytes or file): Path or file handle to save CSV
        """
        write_dict = {ensure_str(col): self[col] for col in self.columns}
        # write columns in order
        cols_array = np.array(
            [ensure_binary(col) for col in self.columns],
            dtype=np.bytes_,  # pylint: disable=no-member
        )
        np.savez(file_path_or_handle, __columns__=cols_array, **write_dict)

    @staticmethod
    def from_npz(file_path_or_handle, **kwargs):
        """Read CSV from a .npz file.

        Args:
            file_path_or_handle (bytes or file): Path or open file handle to CSV
            **kwargs: additional arguments passed to `np.load`.

        Returns:
            SimpleCSV: Deserializes content into a SimpleCSV object
        """
        data_csv = SimpleCSV()
        with np.load(file_path_or_handle, **kwargs) as data:
            columns = [ensure_str(col) for col in data[SimpleCSV.COLUMNS_FIELD]]
            for col in columns:
                data_csv[col] = data[col]
        return data_csv

    def to_csv(self, file_path):
        """Write object to a CSV file.

        Args:
            file_path (PATH): Path to CSV file
        """

        def to_bytes(col: np.ndarray, i: int) -> bytes:
            """Convert the i'th element of col to a bytes object.

            The problem with just using np.str for this is that it will print
            `b"xyz"` as `b'xyz'` when what we want is `xyz`
            """
            if col.dtype.char == "S":
                return col[i]
            return ensure_binary(np.str(col[i]))

        with open(file_path, "wb") as out:
            for i, col in enumerate(self.columns):
                if i:
                    out.write(b",")
                out.write(ensure_binary(col))
            out.write(b"\n")

            for i in range(self.shape[0]):
                for j, col in enumerate(self.columns):
                    if j:
                        out.write(b",")
                    out.write(to_bytes(getattr(self, col), i))
                out.write(b"\n")
